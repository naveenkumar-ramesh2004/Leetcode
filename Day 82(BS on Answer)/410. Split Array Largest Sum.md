## [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/description/)
```
class Solution {
    public int splitArray(int[] nums, int k) {
        int low=0,high=0;
        for(int val:nums){
            low=Math.max(low,val);
            high+=val;
        }
        return maxSumMinlen(nums,k,low,high);
    }
    int maxSumMinlen(int nums[],int k,int low,int high){
        while(low<high){
            int mid=(low+high)/2;
            if(canDo(mid,nums,k)){
                high=mid;
            }
            else{
                low=mid+1;
            }
        }
        return low;
    }
    boolean canDo(int X,int[] nums,int k){
        int sum=0;
        int count=1;
        for(int val:nums){
            if(sum+val>X){
                sum=val;
                count++;
            }
            else{
                sum+=val;
            }
        }
        return count<=k;
        
    }
    
}



```
### â­ FIRST: Why these weird problems are STILL Binary Search?

You asked:

â€œThe array is not sorted. How is this Binary Search???â€

âœ” Correct â€” these problems are NOT searching inside array.
âœ” They are searching inside the range of possible answers.

Let me repeat slowly:

â— We are NOT Binary Searching the ARRAY
â— We ARE Binary Searching the ANSWER

This is called:

â­ Binary Search on Answer

(also called Parametric Search)

This is the biggest unlock in DSA.

### â­ SECOND: The REAL trick â€” Convert problem into a YES/NO question

Binary Search ALWAYS needs:

A sorted search space

A monotonic condition (if you cross a point, the truth changes from False to True)

In these problems:

We create a search space of possible answers,

not input array values.

Then we ask:

If we assume answer = X,
can we complete the job with X?

This â€œYES / NOâ€ forms a sorted pattern.

### â­ THIRD: Why â€œSplit Array Largest Sumâ€ is Binary Search

Letâ€™s see the possible answers (max subarray sum) for:

[7,2,5,10,8], k = 2

Minimum possible answer = max element = 10

(because no subarray can have sum < 10)

Maximum possible answer = total sum = 32

(if we don't split at all)

So answer is between:

[10 .................................................. 32]


Now imagine checking X = 16:

Ask:

â€œCan I split the array into 2 parts so that no part has sum > 16?â€

If YES â†’ we try smaller X
If NO â†’ X is too small, try higher X

This creates a monotonic truth pattern:

10    11    12    13    14    15    16    17    18    â€¦ 32
F     F     F     F     F     F     F     F     T         T


Observe:

â— All smaller values fail
â— All bigger values succeed

This is EXACT SHAPE of Binary Search.

### â­ FOURTH: IMPORTANT â€” You NEVER guess X manually

You asked:

â€œHow do we come up with X? How to find the correct X?â€

You NEVER guess manually.
Binary search chooses X for you.

You ONLY define:

low = max element

high = sum of array

Binary Search tries:

mid = (low + high) / 2


And asks:

â€œIf mid is max allowed sum, can we split the array into k parts?â€

YOU never choose X â€”
Binary Search chooses X automatically on each iteration.

### â­ FIFTH: Why this ALWAYS works?

Because the pattern of YES/NO is monotonic.

Let me demonstrate:

If X is very small (like 10â€“15)

= too small â†’ cannot split into k parts â†’ FAIL

If X is medium (16â€“17)

still cannot split into 2 parts â†’ FAIL

If X is big enough (18)

splitting possible â†’ SUCCESS

If X is even bigger (25â€“32)

still possible â†’ SUCCESS

So the truth pattern is:

FFF FFF FTTTTTT


This is PERFECT for Binary Search.

Binary Search ALWAYS finds the FIRST TRUE.

### â­ SIXTH: Why this problem BELONGS to Binary Search

Because of these clues:

âœ” You need to minimize a maximum

(very big hint)

âœ” The answer lies in a range (not the array)

(from max element to total sum)

âœ” There is a monotonic condition

(smaller values fail â†’ bigger values pass)

âœ” You can test mid using simulation

(canSplit(nums, mid, k))

âœ” You need to find the smallest X that satisfies a condition

(BS on answer is perfect here)

These are the patterns you MUST learn to detect.

### â­ SEVENTH: When should you think â€œBinary Search on Answerâ€?

Here is a perfect rule for you:

ğŸ”¥ If the problem says:
â€œMinimum possible X such that â€¦â€
â€œMaximum possible X such that â€¦â€
â€œMinimize the largest â€¦â€
â€œFind smallest capacity â€¦â€
â€œFind minimum speed â€¦â€
â€œFind minimum time â€¦â€
â€œFind minimum number â€¦â€
â€œCan we do this under X constraint?â€

Then it is ALMOST ALWAYS:

â­ Binary Search on Answer

This is your magic cheat code.

### â­ EIGHTH: Example mapping
âœ” Koko Eating Bananas

â†’ minimize speed X such that can finish

âœ” Ship Packages

â†’ minimize capacity X such that can deliver

âœ” Split Array Largest Sum

â†’ minimize maximum subarray sum X such that can split

âœ” Aggressive Cows

â†’ maximize minimum distance X between cows

âœ” Painter Partition

â†’ minimize max time X required to paint boards

Same pattern everywhere.

### â­ FINAL SUMMARY (Your Ultimate Understanding)
âœ” You are NOT searching inside the array
âœ” You are searching inside the range of possible answers (X)
âœ” You test each X using a simulation function (canDo(X))
âœ” The YES/NO results create a sorted truth pattern
âœ” Binary Search finds the smallest X that gives YES

That's ALL.

Once this enters your head, Binary Search on Answer becomes EASY.
