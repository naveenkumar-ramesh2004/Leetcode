//120. Triangle
//https://leetcode.com/problems/triangle/description/?envType=daily-question&envId=2025-09-23



// It won't work beacuse I calculate all path to find the minium.


// class Solution {
//     public int minimumTotal(List<List<Integer>> triangle) {
//         int sum=0;
//         int min=triangle.get(0).get(0);
//         int idx=0;
//         for(List<Integer> arr:triangle){
//         // for(int i=0;i<triangle.size();i++){
//             // int prev=Integer.MAX_VALUE;
//             // for(int val:arr){
//             for(int j=0;j<arr.size();j++){
//                 int temp=0;
//                 int prev=Integer.MAX_VALUE;
//                for(int i=idx;i<=idx+1 && i<arr.size();i++){
//                int current=sum+arr.get(i);
//                 if(current<prev){
//                     min=current;
//                     temp=i;
//                     System.out.print(temp);
//                 }
//                 prev=min;

//                 System.out.println(min);
//                }
//                idx=temp;
//             }

//             sum=min;
//         }
//         return sum;
//     }
// }

//Copy paste code for explaination


// class Solution {
//     public int minimumTotal(List<List<Integer>> triangle) {
//         int n = triangle.size();

//         // Copy last row as starting dp (base case)
//         int[] dp = new int[n];
//         for (int j = 0; j < n; j++) {
//             dp[j] = triangle.get(n-1).get(j);
//         }

//         // Bottom-up: from 2nd last row → top
//         for (int i = n-2; i >= 0; i--) {
//             for (int j = 0; j <= i; j++) {
//                 // pick min of two adjacent numbers
//                 dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j+1]);
//             }
//         }

//         return dp[0]; // min path starts from top
//     }
// }

//It is optimize code DP down to top

class Solution{
    public int minimumTotal(List<List<Integer>> triangle) {
        int n=triangle.size();
        int[] path = new int[n];
        for(int i=0;i<n;i++){
            path[i]=triangle.get(n-1).get(i);
        } 
        for(int i=n-2;i>=0;i--){
            for(int j=0;j<=i;j++){
                path[j]=triangle.get(i).get(j)+Math.min(path[j],path[j+1]);
            }
        }
        return path[0];
    }
}


//Dynamic Programming is a method to solve problems by breaking them into smaller subproblems and storing (remembering) the results of those subproblems so you don’t calculate them again.

//DP = remember your work.
//Instead of solving the same thing again and again, solve once → save it → reuse it.

/*
-1
  2  3
 1 -1 -3
Initialize dp with last row: [1, -1, -3]

Process row 1 ([2,3]):

For j=0: 2 + min(1, -1) = 2 + (-1) = 1 → dp[0] = 1

For j=1: 3 + min(-1, -3) = 3 + (-3) = 0 → dp[1] = 0

dp is now [1,0,-3] (we only care about first two elements for row 1)

Process row 0 ([-1]):

j=0: -1 + min(1,0) = -1 + 0 = -1 → dp[0] = -1

✅ After the loops
dp[0] contains the minimum path sum from the top to the bottom.

That’s why the function returns dp[0].

*/
